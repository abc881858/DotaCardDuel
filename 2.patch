Index: card.cpp
===================================================================
--- card.cpp	(版本 49)
+++ card.cpp	(工作副本)
@@ -229,6 +229,7 @@
     }
     else if (pickRequirement == AttackedRequirement)
     {
+        qDebug() << "if area == EnemyFieldyard_Area: " << (area == EnemyFieldyard_Area);
         return (area == EnemyFieldyard_Area);
         //鏃犺琛ㄤ晶閲屼晶锛岄兘鍙互閫夋嫨浣滀负鐩爣target
         //涓嶅啀鍒ゆ柇isMonster浜嗭紝鍓嶆帓鑲畾鏄€槢
@@ -463,7 +464,8 @@
     {
         if (currentflag == Selectable)
         {
-            activePicked();
+            qDebug() << "emit pickTarget()";
+            emit pickTarget();
         }
         else if (currentflag == Effect)
         {
@@ -509,7 +511,7 @@
         else if (currentflag == Attack)
         {
             Rule::instance()->setPickRequirement(AttackedRequirement);
-            //emit clickSword();
+            setOneTurnOneAttack(false);
         }
     }
 }
Index: card.h
===================================================================
--- card.h	(版本 47)
+++ card.h	(工作副本)
@@ -168,7 +168,6 @@
     virtual bool testEffect() { return false; }
     virtual void activeEffect() {}
     virtual void activeHandEffect() {}
-    void activePicked();
 
     bool getChangePosition() const;
     void setChangePosition(bool value); //area闇€瑕?@@ -231,6 +230,7 @@
     void normalSummon();
     void setCard();
     void tribute();
+    void pickTarget();
 };
 
 Q_DECLARE_OPERATORS_FOR_FLAGS(Card::CardFlags)
Index: cardeffect.cpp
===================================================================
--- cardeffect.cpp	(版本 49)
+++ cardeffect.cpp	(工作副本)
@@ -9,76 +9,17 @@
 #include "net.h"
 #include "rule.h"
 
-void Card::activePicked() //娉ㄦ剰锛氳繖鏄綘閫夋嫨鐨勫崱锛屼笉鏄彂鍔ㄦ晥鏋滅殑鍗★紒閫夊ソ浜嗗崱鐗岋紝鐪熸active锛屽苟鍙戦€丯et
+void RoomScene::response_AttackEffect(QJsonObject jsonObject) //鏀跺埌Net娑堟伅鐨勫绔仛鍑哄弽搴? {
-    bool oldFace = face;
-    int oldArea = area;
-    bool oldStand = stand;
-    int oldIndex = index;
-
-    int pickRequirement = Rule::instance()->getPickRequirement();
-    qDebug() << "Card::activePicked() pickRequirement: " << pickRequirement;
-
-    if (pickRequirement == AttackedRequirement)
-    {
-        //
-    }
-    else if (pickRequirement == KeeperoftheLightRequirement)
-    {
-        //缁欓€夋嫨鐨勫鏂瑰崱鐗屼竴涓猟ebuff
-        setDebuff(KeeperoftheLightRequirement);
-    }
-    else if (pickRequirement == KeeperoftheLightRequiremented)
-    {
-        //涓€鑸彧鏈夊姩瀵规柟鍦哄湴鐨勪笢瑗匡紝鎵嶄細瑙﹀彂Net鐩稿叧鐨勪簨浠?-        //濡傛灉鍙姩鑷繁鍦哄湴锛屽洜涓烘湰鍦扮殑add鍜宼ake鍗＄墝閮藉仛浜哊et鍙戝皠锛屾墍浠ュ彲浠ヨ烦杩囥€?-        HandArea::instance()->addCard(FieldyardArea::instance()->takeCard(index));
-    }
-    else if (pickRequirement == LionRequirement)
-    {
-        if (face)
-        {
-            setFace(false);
-            setArea(EnemyFieldyard_Area);
-            setStand(false);
-        }
-        else
-        {
-            //涓嶅簲璇ュ幓鎿嶄綔浠讳綍 EnemyArea 鐨?addCard 鍜宼akeCard锛屽洜涓鸿繖浼氳Е鍙戝鏂瑰啀娆″彂閫佺粰鎴慳dd鍜宼ake锛岃浣忥紒
-            //EnemyGraveyardArea::instance()->response_addCard(EnemyFieldyardArea::instance()->response_takeCard(index));
-        }
-    }
-
-    QJsonObject parameter;
-    parameter.insert("oldFace", oldFace);
-    parameter.insert("oldArea", oldArea); //鐐瑰嚮鐨勫崱鐨勬棫浣嶇疆
-    parameter.insert("oldStand", oldStand);
-    parameter.insert("oldIndex", oldIndex);
-    parameter.insert("newFace", face);
-    parameter.insert("newArea", area); //鐐瑰嚮鐨勫崱鐨勬柊浣嶇疆
-    parameter.insert("newStand", stand);
-    parameter.insert("newIndex", index);
-    QJsonObject object;
-    QString request = QString(Rule::instance()->NameEffected[pickRequirement]).append("Effect");
-    qDebug() << "I have actived some card's effect! The effect is : " << request;
-    object.insert("request", request);
-    object.insert("parameter", parameter);
-    Net::instance()->write(object);
-
-    Rule::instance()->setPickRequirement(NoRequiremente);
-}
-
-void RoomScene::response_AttackEffect(QJsonObject jsonObject)
-{
     QJsonObject parameter = jsonObject["parameter"].toObject();
     int oldIndex = parameter["oldIndex"].toInt();
     //zhao gu fa qi fang de DONGHUA!
-    QPropertyAnimation* animation = new QPropertyAnimation(sword[currentMove], "pos");
-    animation->setDuration(1000);
-//    animation->setStartValue(sword[currentMove].pos());
-    animation->setEndValue(QPointF(210, 20));
-    animation->setEasingCurve(QEasingCurve::OutBounce);
-    animation->start();
+//    QPropertyAnimation* animation = new QPropertyAnimation(sword[currentMove], "pos");
+//    animation->setDuration(1000);
+//    //    animation->setStartValue(sword[currentMove].pos());
+//    animation->setEndValue(QPointF(210, 20));
+//    animation->setEasingCurve(QEasingCurve::OutBounce);
+//    animation->start();
 }
 
 void RoomScene::response_CentaurWarrunnerEffect(QJsonObject jsonObject)
Index: graphicspixmapobject.cpp
===================================================================
--- graphicspixmapobject.cpp	(版本 49)
+++ graphicspixmapobject.cpp	(工作副本)
@@ -7,10 +7,11 @@
     setTransformationMode(Qt::SmoothTransformation);
 }
 
-void GraphicsPixmapObject::mousePressEvent(QGraphicsSceneMouseEvent *)
+void GraphicsPixmapObject::mousePressEvent(QGraphicsSceneMouseEvent *event)
 {
     if(canClick)
     {
         emit canMove();
     }
+    QGraphicsPixmapItem::mousePressEvent(event);
 }
Index: graphicspixmapobject.h
===================================================================
--- graphicspixmapobject.h	(版本 47)
+++ graphicspixmapobject.h	(工作副本)
@@ -3,6 +3,7 @@
 
 #include <QObject>
 #include <QGraphicsPixmapItem>
+#include <QGraphicsSceneMouseEvent>
 
 //Scene涓墍鏈夊彲浠ュ姩鐨処tem閮界敤杩欎釜绫? class GraphicsPixmapObject : public QObject, public QGraphicsPixmapItem
@@ -13,7 +14,7 @@
     GraphicsPixmapObject();
     bool canClick;
 protected:
-    virtual void mousePressEvent(QGraphicsSceneMouseEvent *);
+    virtual void mousePressEvent(QGraphicsSceneMouseEvent *event);
 signals:
     void canMove();
 };
Index: roomscene.cpp
===================================================================
--- roomscene.cpp	(版本 49)
+++ roomscene.cpp	(工作副本)
@@ -100,8 +100,17 @@
         sword[i].canClick = true;
         sword[i].hide();
     }
+
     currentMove = -1;
 
+    for (int j = 5; j < 10; j++)
+    {
+        sword[j].setPixmap(QPixmap(":/png/png/sword.png"));
+        sword[j].setPos(QPointF(320 - 80 * (j - 5), 0) + EnemyFieldyardPos);
+        addItem(&sword[j]);
+        sword[j].hide();
+    }
+
     duifangxingdong = new GraphicsPixmapObject;
     duifangxingdong->setPixmap(QPixmap(":/png/png/dfxd"));
     addItem(duifangxingdong);
@@ -132,9 +141,77 @@
     connect(Net::instance(), SIGNAL(request_ZeusEffect(QJsonObject)), this, SLOT(response_ZeusEffect(QJsonObject)));
 }
 
+void RoomScene::doPickTarget() //娉ㄦ剰锛氳繖鏄綘閫夋嫨鐨勫崱锛屼笉鏄彂鍔ㄦ晥鏋滅殑鍗★紒閫夊ソ浜嗗崱鐗岋紝鐪熸active锛屽苟鍙戦€丯et
+{
+    Card* card = qobject_cast<Card*>(sender());
+    bool oldFace = card->getFace();
+    int oldArea = card->getArea();
+    bool oldStand = card->getStand();
+    int oldIndex = card->getIndex();
+
+    int pickRequirement = Rule::instance()->getPickRequirement();
+    qDebug() << "Card::doPickTarget() pickRequirement: " << pickRequirement;
+
+    if (pickRequirement == AttackedRequirement)
+    {
+        QPropertyAnimation* animation = new QPropertyAnimation(&sword[currentMove], "pos");
+        animation->setDuration(1000);
+        animation->setStartValue(sword[currentMove].pos());
+        animation->setEndValue(sword[4 + oldIndex].pos());
+        animation->setEasingCurve(QEasingCurve::Linear);
+        animation->start();
+        connect(animation, &QPropertyAnimation::finished, [=]()
+            {
+                sword[currentMove].hide();
+            });
+    }
+    else if (pickRequirement == KeeperoftheLightRequirement)
+    {
+        //缁欓€夋嫨鐨勫鏂瑰崱鐗屼竴涓猟ebuff
+        card->setDebuff(KeeperoftheLightRequirement);
+    }
+    else if (pickRequirement == KeeperoftheLightRequiremented)
+    {
+        //涓€鑸彧鏈夊姩瀵规柟鍦哄湴鐨勪笢瑗匡紝鎵嶄細瑙﹀彂Net鐩稿叧鐨勪簨浠?+        //濡傛灉鍙姩鑷繁鍦哄湴锛屽洜涓烘湰鍦扮殑add鍜宼ake鍗＄墝閮藉仛浜哊et鍙戝皠锛屾墍浠ュ彲浠ヨ烦杩囥€?+        HandArea::instance()->addCard(FieldyardArea::instance()->takeCard(oldIndex));
+    }
+    else if (pickRequirement == LionRequirement)
+    {
+        if (oldFace)
+        {
+            card->setFace(false);
+            card->setArea(EnemyFieldyard_Area);
+            card->setStand(false);
+        }
+        else
+        {
+            //涓嶅簲璇ュ幓鎿嶄綔浠讳綍 EnemyArea 鐨?addCard 鍜宼akeCard锛屽洜涓鸿繖浼氳Е鍙戝鏂瑰啀娆″彂閫佺粰鎴慳dd鍜宼ake锛岃浣忥紒
+            //EnemyGraveyardArea::instance()->response_addCard(EnemyFieldyardArea::instance()->response_takeCard(index));
+        }
+    }
+
+    QJsonObject parameter;
+    parameter.insert("oldFace", oldFace);
+    parameter.insert("oldArea", oldArea); //鐐瑰嚮鐨勫崱鐨勬棫浣嶇疆
+    parameter.insert("oldStand", oldStand);
+    parameter.insert("oldIndex", oldIndex);
+    parameter.insert("newFace", card->getFace());
+    parameter.insert("newArea", card->getArea()); //鐐瑰嚮鐨勫崱鐨勬柊浣嶇疆
+    parameter.insert("newStand", card->getStand());
+    parameter.insert("newIndex", card->getIndex());
+    QJsonObject object;
+    QString request = QString(Rule::instance()->NameEffected[pickRequirement]).append("Effect");
+    qDebug() << "I have actived some card's effect! The effect is : " << request;
+    object.insert("request", request);
+    object.insert("parameter", parameter);
+    Net::instance()->write(object);
+
+    Rule::instance()->setPickRequirement(NoRequiremente);
+}
+
 void RoomScene::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
 {
-    QGraphicsScene::mouseMoveEvent(event);
     if (currentMove != -1)
     {
         qDebug() << "3333: " << sword[currentMove].pos() << "4444: " << event->scenePos(); //鍘熸潵鏄痵cenePos锛屼笉鏄痯os()!
@@ -145,6 +222,7 @@
         qDebug() << "angle: " << angle;
         sword[currentMove].setRotation(angle); //angle鏄姬搴?
     }
+    QGraphicsScene::mouseMoveEvent(event);
 }
 
 //void RoomScene::mousePressEvent(QGraphicsSceneMouseEvent *event)
@@ -201,6 +279,7 @@
                 QString description = card->getDescription();
                 emit hover(name, description);
             });
+        connect(card, SIGNAL(pickTarget()), this, SLOT(doPickTarget())); //閫夋嫨瀵规柟鍗＄墝鏃惰Е鍙?         EnemyDeckArea::instance()->response_addCard(card);
         break;
     }
@@ -253,9 +332,19 @@
 {
     int phase = jsonObject["phase"].toInt();
     Rule::instance()->setPhase(phase + 6);
-    if(phase == Rule::myBP)
+    if (phase == 3)
     {
-        //
+        //TODO: 1.鏄惁鍙敤鍦╯etPhase::MyBP鐨勬椂鍊欏姞杞斤紵
+        //2.灏辩畻鍦ㄨ繖鍔犺浇锛屼篃涓嶄竴瀹氳鍏ㄩ儴鏄剧ず涓哄疂鍓戝惂锛?+        for (Card* card : EnemyFieldyardArea::instance()->getYourFieldyard())
+        {
+            if (card->getFace() && card->getStand())
+            {
+                //Fieldyard 鐨刬ndex鏄粠1-5鐨? 瀵瑰簲鐨剆word鏁扮粍涓嬫爣鏄?-4
+                //EnemyFieldyard 鐨刬ndex鏄粠 1-5, 瀵瑰簲鐨剆word鏁扮粍涓嬫爣鏄?-9
+                sword[4 + card->getIndex()].show();
+            }
+        }
     }
 }
 
@@ -312,6 +401,7 @@
                 FieldyardArea::instance()->takeCard(card->getIndex());
                 GraveyardArea::instance()->addCard(card);
             });
+        connect(card, SIGNAL(pickTarget()), this, SLOT(doPickTarget()));
     }
     file.close();
 
@@ -427,8 +517,6 @@
 
     if (phase == Rule::myBP)
     {
-        //TODO: 1.鏄惁鍙敤鍦╯etPhase::MyBP鐨勬椂鍊欏姞杞斤紵
-        //2.灏辩畻鍦ㄨ繖鍔犺浇锛屼篃涓嶄竴瀹氳鍏ㄩ儴鏄剧ず涓哄疂鍓戝惂锛?         for (Card* card : FieldyardArea::instance()->getMyFieldyard())
         {
             if (card->getFace() && card->getStand())
Index: roomscene.h
===================================================================
--- roomscene.h	(版本 49)
+++ roomscene.h	(工作副本)
@@ -15,7 +15,7 @@
 public:
     explicit RoomScene(QObject* parent = 0);
     Card* enemyTakedCard;
-    GraphicsPixmapObject sword[5];
+    GraphicsPixmapObject sword[10];
     GraphicsPixmapObject* duifangxingdong;
     //    GraphicsPixmapObject currentSword;
     int currentMove;
@@ -58,6 +58,7 @@
     void response_ZeusEffect(QJsonObject);
 
     void response_AttackEffect(QJsonObject jsonObject);
+    void doPickTarget();
 
     //protected:
     //    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event);
