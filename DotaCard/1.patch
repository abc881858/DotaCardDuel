Index: card.cpp
===================================================================
--- card.cpp	(版本 47)
+++ card.cpp	(工作副本)
@@ -28,7 +28,14 @@
 
 Card::CardFlags Card::testAll()
 {
-    testEffect() ? setCardFlag(Effect, true) : setCardFlag(Effect, false);
+    if(testEffect() && Rule::instance()->getPickRequirement()==0)
+    {
+        setCardFlag(Effect, true);
+    }
+    else
+    {
+        setCardFlag(Effect, false);
+    }
     testSpecialSummon() ? setCardFlag(SpecialSummon, true) : setCardFlag(SpecialSummon, false);
     testNormalSummon() ? setCardFlag(NormalSummon, true) : setCardFlag(NormalSummon, false);
     testSetCard() ? setCardFlag(SetCard, true) : setCardFlag(SetCard, false);
@@ -210,7 +217,7 @@
     return false;
 }
 
-bool Card::testSelectable()
+bool Card::testSelectable() //TODO 鍙互鍔犲叆鏇村select鍐呭
 {
     int pickRequirement = Rule::instance()->getPickRequirement();
 
@@ -220,6 +227,12 @@
     {
         return false;
     }
+    else if (pickRequirement == AttackedRequirement)
+    {
+        return (area == EnemyFieldyard_Area);
+        //鏃犺琛ㄤ晶閲屼晶锛岄兘鍙互閫夋嫨浣滀负鐩爣target
+        //涓嶅啀鍒ゆ柇isMonster浜嗭紝鍓嶆帓鑲畾鏄€槢
+    }
     else if (pickRequirement == KeeperoftheLightRequirement)
     {
         return (area == EnemyFieldyard_Area && face && isMonstor());
@@ -360,6 +373,7 @@
 {
     setCursor(QCursor(QPixmap(":/png/png/3.cur"), 31, 15));
     //TODO: 绉婚櫎 鍥涜閫夋嫨妗?+    //鍏跺疄涓嶅Θ鍙互娓呴櫎 currentflag
 
     if (area == Hand_Area || area == EnemyHand_Area)
     {
Index: cardeffect.cpp
===================================================================
--- cardeffect.cpp	(版本 47)
+++ cardeffect.cpp	(工作副本)
@@ -2,6 +2,7 @@
 
 #include <QDebug>
 #include <QMessageBox>
+#include <QPropertyAnimation>
 
 #include "area.h"
 #include "card.h"
@@ -17,8 +18,13 @@
 
     int pickRequirement = Rule::instance()->getPickRequirement();
     qDebug() << "Card::activePicked() pickRequirement: " << pickRequirement;
-    if (pickRequirement == KeeperoftheLightRequirement)
+
+    if (pickRequirement == AttackedRequirement)
     {
+        //
+    }
+    else if (pickRequirement == KeeperoftheLightRequirement)
+    {
         //缁欓€夋嫨鐨勫鏂瑰崱鐗屼竴涓猟ebuff
         setDebuff(KeeperoftheLightRequirement);
     }
@@ -45,11 +51,11 @@
 
     QJsonObject parameter;
     parameter.insert("oldFace", oldFace);
-    parameter.insert("oldArea", oldArea);//鐐瑰嚮鐨勫崱鐨勬棫浣嶇疆
+    parameter.insert("oldArea", oldArea); //鐐瑰嚮鐨勫崱鐨勬棫浣嶇疆
     parameter.insert("oldStand", oldStand);
     parameter.insert("oldIndex", oldIndex);
     parameter.insert("newFace", face);
-    parameter.insert("newArea", area);//鐐瑰嚮鐨勫崱鐨勬柊浣嶇疆
+    parameter.insert("newArea", area); //鐐瑰嚮鐨勫崱鐨勬柊浣嶇疆
     parameter.insert("newStand", stand);
     parameter.insert("newIndex", index);
     QJsonObject object;
@@ -62,6 +68,19 @@
     Rule::instance()->setPickRequirement(NoRequiremente);
 }
 
+void RoomScene::response_AttackEffect(QJsonObject jsonObject)
+{
+    QJsonObject parameter = jsonObject["parameter"].toObject();
+    int oldIndex = parameter["oldIndex"].toInt();
+    //zhao gu fa qi fang de DONGHUA!
+    QPropertyAnimation* animation = new QPropertyAnimation(sword[currentMove], "pos");
+    animation->setDuration(1000);
+//    animation->setStartValue(sword[currentMove].pos());
+    animation->setEndValue(QPointF(210, 20));
+    animation->setEasingCurve(QEasingCurve::OutBounce);
+    animation->start();
+}
+
 void RoomScene::response_CentaurWarrunnerEffect(QJsonObject jsonObject)
 {
     bool all = jsonObject["all"].toBool();
@@ -77,18 +96,18 @@
 
 void RoomScene::response_KeeperoftheLightEffect(QJsonObject jsonObject)
 {
-//    int oldArea = jsonObject["oldArea"].toInt();
-//    int oldIndex = jsonObject["oldIndex"].toInt();
-//    if (oldArea == Hand_Area)
-//    {
-//        //EnemyHandArea::instance()->response_addCard(EnemyFieldyardArea::instance()->response_takeCard(oldIndex));
-//    }
-//    else if (oldArea == Fieldyard_Area)
-//    {
-//        Card* card = FieldyardArea::instance()->getMyFieldyard().at(oldIndex);
-//        //閫夋嫨鐨勬€吔鍦ㄨ繘琛屾敾鍑诲瑷€鍓嶅繀椤讳涪寮冧竴寮犳墜鐗?-//        card->setDebuff(KeeperoftheLightRequirement);
-//    }
+    //    int oldArea = jsonObject["oldArea"].toInt();
+    //    int oldIndex = jsonObject["oldIndex"].toInt();
+    //    if (oldArea == Hand_Area)
+    //    {
+    //        //EnemyHandArea::instance()->response_addCard(EnemyFieldyardArea::instance()->response_takeCard(oldIndex));
+    //    }
+    //    else if (oldArea == Fieldyard_Area)
+    //    {
+    //        Card* card = FieldyardArea::instance()->getMyFieldyard().at(oldIndex);
+    //        //閫夋嫨鐨勬€吔鍦ㄨ繘琛屾敾鍑诲瑷€鍓嶅繀椤讳涪寮冧竴寮犳墜鐗?+    //        card->setDebuff(KeeperoftheLightRequirement);
+    //    }
 }
 
 void RoomScene::response_LionEffect(QJsonObject jsonObject)
Index: DotaCard.pro
===================================================================
--- DotaCard.pro	(版本 47)
+++ DotaCard.pro	(工作副本)
@@ -1,58 +1,54 @@
-#-------------------------------------------------
-#
-# Project created by QtCreator 2015-10-18T23:01:38
-# have 3400 line text at 2016-10-16 8:18:41
-#
-#-------------------------------------------------
-
-QT       += core gui websockets
-
-greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
-
-# With C++11 support
-CONFIG += c++11
-CONFIG += warn_on
-
-TARGET = DotaCard
-TEMPLATE = app
-
-
-SOURCES += main.cpp\
-        mainwindow.cpp \
-    card.cpp \
-    roomscene.cpp \
-    area.cpp \
-    engine.cpp \
-    net.cpp \
-    rule.cpp \
-    cardeffect.cpp \
-    graphicspixmapobject.cpp
-
-HEADERS  += mainwindow.h \
-    card.h \
-    roomscene.h \
-    area.h \
-    engine.h \
-    net.h \
-    rule.h \
-    graphicspixmapobject.h
-
-FORMS    += mainwindow.ui
-
-RESOURCES += \
-    res.qrc
-
-#QMAKE_TARGET_COMPANY = Home
-#QMAKE_TARGET_DESCRIPTION = Detailed Description
-#QMAKE_TARGET_COPYRIGHT = CopyRight
-#QMAKE_TARGET_PRODUCT = DotaCard
-#RC_CODEPAGE
-#RC_ICONS
-#RC_LANG
-#VERSION = 1.1.0
-
-win32 {
-QMAKE_CXXFLAGS+=/wd"4819"
-}
-
-TRANSLATIONS += dc_zh_cn.ts
+#-------------------------------------------------
+#
+# Project created by QtCreator 2015-10-18T23:01:38
+# have 3400 line text at 2016-10-16 8:18:41
+#
+#-------------------------------------------------
+
+QT       += core gui websockets
+
+greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
+
+# With C++11 support
+CONFIG += c++11
+CONFIG += warn_on
+
+TARGET = DotaCard
+TEMPLATE = app
+
+
+SOURCES += main.cpp\
+        mainwindow.cpp \
+    card.cpp \
+    roomscene.cpp \
+    area.cpp \
+    engine.cpp \
+    net.cpp \
+    rule.cpp \
+    cardeffect.cpp \
+    graphicspixmapobject.cpp
+
+HEADERS  += mainwindow.h \
+    card.h \
+    roomscene.h \
+    area.h \
+    engine.h \
+    net.h \
+    rule.h \
+    graphicspixmapobject.h
+
+FORMS    += mainwindow.ui
+
+RESOURCES += \
+    res.qrc
+
+#QMAKE_TARGET_COMPANY = Home
+#QMAKE_TARGET_DESCRIPTION = Detailed Description
+#QMAKE_TARGET_COPYRIGHT = CopyRight
+#QMAKE_TARGET_PRODUCT = DotaCard
+#RC_CODEPAGE
+#RC_ICONS
+#RC_LANG
+#VERSION = 1.1.0
+
+TRANSLATIONS += dc_zh_cn.ts
Index: graphicspixmapobject.cpp
===================================================================
--- graphicspixmapobject.cpp	(版本 0)
+++ graphicspixmapobject.cpp	(工作副本)
@@ -0,0 +1,16 @@
+#include "graphicspixmapobject.h"
+
+GraphicsPixmapObject::GraphicsPixmapObject()
+{
+    canClick = false;
+    setTransformOriginPoint(25,36);
+    setTransformationMode(Qt::SmoothTransformation);
+}
+
+void GraphicsPixmapObject::mousePressEvent(QGraphicsSceneMouseEvent *)
+{
+    if(canClick)
+    {
+        emit canMove();
+    }
+}
Index: roomscene.cpp
===================================================================
--- roomscene.cpp	(版本 47)
+++ roomscene.cpp	(工作副本)
@@ -40,16 +40,16 @@
 {
     setBackgroundBrush(QBrush(QPixmap(":/png/png/b.png")));
 
-//    myContextMenu = new QMenu;
-//    goBP = new QAction("goBP", myContextMenu);
-//    goM2 = new QAction("goM2", myContextMenu);
-//    goEP = new QAction("goEP", myContextMenu);
-//    myContextMenu->addAction(goBP);
-//    myContextMenu->addAction(goM2);
-//    myContextMenu->addAction(goEP);
-//    connect(goBP, SIGNAL(triggered(bool)), this, SLOT(actionBP(bool)));
-//    connect(goM2, SIGNAL(triggered(bool)), this, SLOT(actionM2(bool)));
-//    connect(goEP, SIGNAL(triggered(bool)), this, SLOT(actionEP(bool)));
+    //    myContextMenu = new QMenu;
+    //    goBP = new QAction("goBP", myContextMenu);
+    //    goM2 = new QAction("goM2", myContextMenu);
+    //    goEP = new QAction("goEP", myContextMenu);
+    //    myContextMenu->addAction(goBP);
+    //    myContextMenu->addAction(goM2);
+    //    myContextMenu->addAction(goEP);
+    //    connect(goBP, SIGNAL(triggered(bool)), this, SLOT(actionBP(bool)));
+    //    connect(goM2, SIGNAL(triggered(bool)), this, SLOT(actionM2(bool)));
+    //    connect(goEP, SIGNAL(triggered(bool)), this, SLOT(actionEP(bool)));
 
     DeckArea::instance()->setPixmap(QPixmap(":/png/png/deck.png"));
     HandArea::instance()->setPixmap(QPixmap(":/png/png/hand.png"));
@@ -88,15 +88,15 @@
     addItem(EnemyFieldgroundArea::instance());
     addItem(EnemyGraveyardArea::instance());
 
-    for(int i=0;i<5;i++)
+    for (int i = 0; i < 5; i++)
     {
         sword[i].setPixmap(QPixmap(":/png/png/sword.png"));
-        sword[i].setPos(QPointF(80*i,0)+FieldyardPos);
+        sword[i].setPos(QPointF(80 * i, 0) + FieldyardPos);
         addItem(&sword[i]);
         connect(&sword[i], &GraphicsPixmapObject::canMove, [=]()
-        {
-            currentMove = i;
-        });
+            {
+                currentMove = i;
+            });
         sword[i].canClick = true;
         sword[i].hide();
     }
@@ -132,16 +132,17 @@
     connect(Net::instance(), SIGNAL(request_ZeusEffect(QJsonObject)), this, SLOT(response_ZeusEffect(QJsonObject)));
 }
 
-void RoomScene::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
+void RoomScene::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
 {
     QGraphicsScene::mouseMoveEvent(event);
     if (currentMove != -1)
     {
-        qDebug() << "3333: " << sword[currentMove].pos() << "4444: " <<event->scenePos();//鍘熸潵鏄痵cenePos锛屼笉鏄痯os()!
-        QPointF p1 = sword[currentMove].pos() + QPointF(25,36);
-        QPointF p2 = sword[currentMove].pos() + QPointF(25,0);
+        qDebug() << "3333: " << sword[currentMove].pos() << "4444: " << event->scenePos(); //鍘熸潵鏄痵cenePos锛屼笉鏄痯os()!
+        QPointF p1 = sword[currentMove].pos() + QPointF(25, 36);
+        QPointF p2 = sword[currentMove].pos() + QPointF(25, 0);
         QPointF p4 = event->scenePos();
-        qreal angle = QLineF(p1,p4).angleTo(QLineF(p1,p2));
+        qreal angle = QLineF(p1, p4).angleTo(QLineF(p1, p2));
+        qDebug() << "angle: " << angle;
         sword[currentMove].setRotation(angle); //angle鏄姬搴?
     }
 }
@@ -148,6 +149,7 @@
 
 //void RoomScene::mousePressEvent(QGraphicsSceneMouseEvent *event)
 //{
+//    if(currentMove != -1)
 //    QGraphicsScene::mousePressEvent(event);
 //    QGraphicsItem* item = itemAt(event->pos(),QTransform());
 //}
@@ -192,7 +194,7 @@
     {
     case Deck_Area:
     {
-        Card* card = Engine::instance()->cloneCard(ISDN);//TODO: 鐜板湪鏂逛究璋冭瘯锛屽姞鍏ュ鏂规墜鐗岀殑hover
+        Card* card = Engine::instance()->cloneCard(ISDN); //TODO: 鐜板湪鏂逛究璋冭瘯锛屽姞鍏ュ鏂规墜鐗岀殑hover
         connect(card, &Card::hover, [=]()
             {
                 QString name = card->getName();
@@ -208,8 +210,8 @@
     case Fieldyard_Area:
         EnemyFieldyardArea::instance()->response_addCard(enemyTakedCard, index, face, stand);
         break;
-//    case Fieldground_Area: //杩樻病瀹炵幇杩欎釜鍑芥暟锛岀瓑榄旈櫡鍗″仛鐨勬椂鍊欏疄鐜?-//        EnemyFieldgroundArea::instance()->response_addCard(enemyTakedCard);
+        //    case Fieldground_Area: //杩樻病瀹炵幇杩欎釜鍑芥暟锛岀瓑榄旈櫡鍗″仛鐨勬椂鍊欏疄鐜?+        //        EnemyFieldgroundArea::instance()->response_addCard(enemyTakedCard);
         break;
     case Graveyard_Area:
         EnemyGraveyardArea::instance()->response_addCard(enemyTakedCard);
@@ -236,9 +238,9 @@
     case Fieldyard_Area:
         enemyTakedCard = EnemyFieldyardArea::instance()->response_takeCard(index);
         break;
-//    case Fieldground_Area: //杩樻病瀹炵幇杩欎釜鍑芥暟锛岀瓑榄旈櫡鍗″仛鐨勬椂鍊欏疄鐜?-//        EnemyFieldgroundArea::instance()->response_takeCard(index);
-//        break;
+    //    case Fieldground_Area: //杩樻病瀹炵幇杩欎釜鍑芥暟锛岀瓑榄旈櫡鍗″仛鐨勬椂鍊欏疄鐜?+    //        EnemyFieldgroundArea::instance()->response_takeCard(index);
+    //        break;
     case Graveyard_Area:
         enemyTakedCard = EnemyGraveyardArea::instance()->response_takeCard(index);
         break;
@@ -256,14 +258,14 @@
 void RoomScene::response_doSetDoing(QJsonObject jsonObject)
 {
     int isDoing = jsonObject["doing"].toBool();
-    if(isDoing)
+    if (isDoing)
     {
         duifangxingdong->show();
 
-        QPropertyAnimation *animation = new QPropertyAnimation(duifangxingdong, "pos");
+        QPropertyAnimation* animation = new QPropertyAnimation(duifangxingdong, "pos");
         animation->setDuration(1000);
-        animation->setStartValue(QPointF(210,0));
-        animation->setEndValue(QPointF(210,20));
+        animation->setStartValue(QPointF(210, 0));
+        animation->setEndValue(QPointF(210, 20));
         animation->setEasingCurve(QEasingCurve::OutBounce);
         animation->start();
     }
@@ -328,7 +330,7 @@
     Rule::instance()->setPhase(Rule::myDP);
     Card* card = DeckArea::instance()->takeCard();
     HandArea::instance()->addCard(card);
-    Net::instance()->sendMessage(20001);//TODO: 鍑嗗淇敼鏈嶅姟鍣ㄥ疄鐜?+    Net::instance()->sendMessage(20001); //TODO: 鍑嗗淇敼鏈嶅姟鍣ㄥ疄鐜? }
 
 void RoomScene::response_standbyPhase()
@@ -344,7 +346,7 @@
              << GraveyardArea::instance()->getMyGraveyard(); //TODO: 鏆傛椂杩樻病鏈夐櫎澶栧尯鍜岄澶栧尯
     for (Card* card : allcards) //閬嶅巻鎵€鏈夊崱鐗岋紝纭繚涓€鍥炲悎涓€娆★紝涓嶄細鍥犱负area鍙樺寲鑰屽娆￠€夊彂
     {
-        card->setOneTurnOneEffect(true);//鐪嬪崱鐗屾槸鍚﹀啓鏄庝竴鍥炲悎涓€娆★紝姣斿鏈夐€佸叆澧撳湴蹇呭彂閫夊彂鐨勬晥鏋?+        card->setOneTurnOneEffect(true); //鐪嬪崱鐗屾槸鍚﹀啓鏄庝竴鍥炲悎涓€娆★紝姣斿鏈夐€佸叆澧撳湴蹇呭彂閫夊彂鐨勬晥鏋?         card->setOneTurnHandEffect(true);
         card->setOneTurnOneAttack(true);
     }
@@ -366,12 +368,12 @@
 {
     Rule::instance()->setDoing(true);
 
-//    Rule::Phase phase = Rule::instance()->getphase();
-//    if (phase == Rule::myDP || phase == Rule::mySP || phase == Rule::myM1
-//        || phase == Rule::myBP || phase == Rule::myM2 || phase == Rule::myEP)
-//    {
-//        return;
-//    }
+    //    Rule::Phase phase = Rule::instance()->getphase();
+    //    if (phase == Rule::myDP || phase == Rule::mySP || phase == Rule::myM1
+    //        || phase == Rule::myBP || phase == Rule::myM2 || phase == Rule::myEP)
+    //    {
+    //        return;
+    //    }
 
     bool responsible = false;
     for (Card* card : FieldyardArea::instance()->getMyFieldyard())
@@ -425,9 +427,9 @@
         //2.灏辩畻鍦ㄨ繖鍔犺浇锛屼篃涓嶄竴瀹氳鍏ㄩ儴鏄剧ず涓哄疂鍓戝惂锛?         for (Card* card : FieldyardArea::instance()->getMyFieldyard())
         {
-            if(card->getFace() && card->getStand())
+            if (card->getFace() && card->getStand())
             {
-                //Fieldyard 鐨刬ndex鏄粠1-5鐨勶紝鍜屽叾浠栫殑濡栬壋璐辫揣涓嶄竴鏍?+                //Fieldyard 鐨刬ndex鏄粠1-5鐨?                 sword[card->getIndex() - 1].show();
             }
         }
Index: roomscene.h
===================================================================
--- roomscene.h	(版本 47)
+++ roomscene.h	(工作副本)
@@ -17,7 +17,7 @@
     Card* enemyTakedCard;
     GraphicsPixmapObject sword[5];
     GraphicsPixmapObject* duifangxingdong;
-//    GraphicsPixmapObject currentSword;
+    //    GraphicsPixmapObject currentSword;
     int currentMove;
 
 private:
@@ -57,12 +57,14 @@
     void response_VengefulSpiritEffect(QJsonObject);
     void response_ZeusEffect(QJsonObject);
 
+    void response_AttackEffect(QJsonObject jsonObject);
+
     //protected:
     //    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event);
 
 protected:
     //    void mousePressEvent(QGraphicsSceneMouseEvent* event);
-    void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
+    void mouseMoveEvent(QGraphicsSceneMouseEvent* event);
 };
 
 #endif // ROOMSCENE_H
Index: rule.cpp
===================================================================
--- rule.cpp	(版本 47)
+++ rule.cpp	(工作副本)
@@ -16,6 +16,7 @@
     // phase 灏变笉鍒濆鍖栦簡
     pickRequirement = 0;
 
+    NameEffected.insert(AttackedRequirement,"Attack");
     NameEffected.insert(KeeperoftheLightRequirement,"KeeperoftheLight");
     NameEffected.insert(KeeperoftheLightRequiremented,"KeeperoftheLight");
     NameEffected.insert(LionRequirement,"Lion");
